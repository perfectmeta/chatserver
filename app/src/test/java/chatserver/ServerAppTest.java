/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package chatserver;

import chatserver.gen.*;
import io.grpc.*;
import io.grpc.Metadata.Key;
import io.grpc.stub.StreamObserver;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.Iterator;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

@SpringBootTest
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class ServerAppTest {


    public static class AuthTokenClientInterceptor implements ClientInterceptor {

        private final String authToken;

        public AuthTokenClientInterceptor(final String authToken) {
            this.authToken = authToken;
        }


        public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(final MethodDescriptor<ReqT, RespT> methodDescriptor, final CallOptions callOptions, final Channel channel) {
            return new ForwardingClientCall.SimpleForwardingClientCall<>(channel.newCall(methodDescriptor, callOptions)) {
                @Override
                public void start(final Listener<RespT> responseListener, final Metadata headers) {

                    headers.put(Key.of("auth_token", Metadata.ASCII_STRING_MARSHALLER), authToken);
                    super.start(responseListener, headers);
                }
            };
        }
    }

    private ChatServiceGrpc.ChatServiceBlockingStub blockingStub;
    private ChatServiceGrpc.ChatServiceStub asyncStub;


    @BeforeAll
    void init() {
        String target = "localhost:8080";
        ManagedChannel channel = Grpc.newChannelBuilder(target, InsecureChannelCredentials.create())
                .intercept(new AuthTokenClientInterceptor("2")).build();  // NOTE: 这个token必须在数据库中，这个测试才能正确。

        blockingStub = ChatServiceGrpc.newBlockingStub(channel);
        asyncStub = ChatServiceGrpc.newStub(channel);
    }

    @Test
    void listRoom() {
        blockingStub.getRoomList(Hello.newBuilder().build()).forEachRemaining(
                roomInfo -> System.out.print("blocking list room ok: " + roomInfo.toString()));
    }

    @Test
    void asyncListRoom() throws InterruptedException {
        CountDownLatch finishLatch = new CountDownLatch(1);
        StreamObserver<RoomInfo> observer = new StreamObserver<>() {

            @Override
            public void onNext(RoomInfo value) {
                System.out.print("async list room ok: " + value);
            }

            @Override
            public void onError(Throwable t) {
                System.err.println(t.getMessage());
                finishLatch.countDown();
            }

            @Override
            public void onCompleted() {
                System.out.println("async list room completed");
                finishLatch.countDown();
            }
        };
        asyncStub.getRoomList(Hello.newBuilder().build(), observer);

        if (!finishLatch.await(1, TimeUnit.SECONDS)) {
            System.out.println("exit! do not wait");
        }
    }

    @Test
    void chat() {
        TextMessage msg = TextMessage.newBuilder().setRoomId(1).setText("are you ok?").build();
        Iterator<TextAudioStream> chat = blockingStub.chat(msg);
        chat.forEachRemaining(textAudioStream -> {
            System.out.print(textAudioStream.getText() + " - ");
        });
    }

}
